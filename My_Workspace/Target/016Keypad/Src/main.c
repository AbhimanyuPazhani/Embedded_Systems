/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include <stdio.h>
#include <stdint.h>

void Delay (void)
{
 for (uint32_t i = 0; i<300000; i++);
}


int main(void)
{
    /* Loop forever */
	uint32_t volatile *const pGPIODModeReg = (uint32_t *) (0x40020C00); // page no: 58
	uint32_t volatile *const pInputDataReg = (uint32_t *) (0x40020C00 + 0x10); //page no 207
	uint32_t volatile *const pOutputDataReg = (uint32_t *) (0x40020C00 + 0x14); //page no 207
	uint32_t volatile *const pClkCtrlReg = (uint32_t *)(0x40023800 + 0x30); //page no: 161
	uint32_t volatile *const pPullupDownReg = (uint32_t *) (0x40020C00 + 0x0C); //Page no 206

	//1. Enable the pripheral clock of GPIOD peripherals
	*pClkCtrlReg |= (1<<3);

	//2. Configure PD0, PD1, PD2, PD3 as output (rows)
	*pGPIODModeReg &= ~ (0xFF); //Clear
	*pGPIODModeReg |= 0x55; //set


	//3. Configure PD8â€“PD11 as input (columns)
	*pGPIODModeReg &= ~ (0xFF << 16);


	//4. Enable internal pull up resistors for PD8, PD9, PD10 and PD11.
	*pPullupDownReg &= ~(0xFF << 16);
	*pPullupDownReg |= (0x55 << 16);

	while(1)
	{
	//Make all rows HIGH
	*pOutputDataReg |= (0x0F);

	//Make R1 Low (R1 is PD0)
	*pOutputDataReg &= ~(1<<0);

	//Scan the columns
	//check C1 (PD8) low or high
	if ( !(*pInputDataReg & (1<<8)) )   //(*pInputDataReg & (1<<8)) If this evaluation returns 0  the key is pressed C1 PB8 if 1 not pressed due to the & operator
	//So, If we use the ! operator 0 is inverted so 0 means 1 and 1 means 0 we did because the loop needs to be evaluated when the key is pressed that means 0.
	{

	//we need to give delay as per the flow chart
	Delay();
	//Key is pressed
	printf ("1\n");
	}

	//Check C2 (PD9) low or high
	if ( !(*pInputDataReg & (1<<9)) )
	{
		//Key is pressed
	Delay();
	printf ("2\n");
	}

	//Check C3 (PD10) low or high
	if ( !(*pInputDataReg & (1<<10)) )
	{
	//Key is pressed
	Delay();
	printf ("3\n");
	}

		//Check C4 (PD11) low or high
	if ( !(*pInputDataReg & (1<<11)) )
	{
	//Key is pressed
	Delay();
	printf ("A\n");
	}

	//Make all rows HIGH
	*pOutputDataReg |= (0x0F);

	//Make R2 Low
	*pOutputDataReg &= ~(1<<1);
	//Scan the columns
	//check C1 (PD8) low or high
	if ( !(*pInputDataReg & (1<<8)) )   //(*pInputDataReg & (1<<8)) If this evaluation returns 0  the key is pressed C1 PB8 if 1 not pressed due to the & operator
	//So, If we use the ! operator 0 is inverted so 0 means 1 and 1 means 0 we did because the loop needs to be evaluated when the key is pressed that means 0.
	{

	//we need to give delay as per the flow chart
	Delay();
	//Key is pressed
	printf ("4\n");
	}

	//Check C2 (PD9) low or high
	if ( !(*pInputDataReg & (1<<9)) )
	{
		//Key is pressed
	Delay();
	printf ("5\n");
	}

	//Check C3 (PD10) low or high
	if ( !(*pInputDataReg & (1<<10)) )
	{
	//Key is pressed
	Delay();
	printf ("6\n");
	}

		//Check C4 (PD11) low or high
	if ( !(*pInputDataReg & (1<<11)) )
	{
	//Key is pressed
	Delay();
	printf ("B\n");
	}

	//Make all rows HIGH
	*pOutputDataReg |= (0x0F);

	//Make R3 Low (PD2)
	*pOutputDataReg &= ~(1<<2);
	//Scan the columns
	//check C1 (PD8) low or high
	if ( !(*pInputDataReg & (1<<8)) )   //(*pInputDataReg & (1<<8)) If this evaluation returns 0  the key is pressed C1 PB8 if 1 not pressed due to the & operator
	//So, If we use the ! operator 0 is inverted so 0 means 1 and 1 means 0 we did because the loop needs to be evaluated when the key is pressed that means 0.
	{

	//we need to give delay as per the flow chart
	Delay();
	//Key is pressed
	printf ("7\n");
	}

	//Check C2 (PD9) low or high
	if ( !(*pInputDataReg & (1<<9)) )
	{
		//Key is pressed
	Delay();
	printf ("8\n");
	}

	//Check C3 (PD10) low or high
	if ( !(*pInputDataReg & (1<<10)) )
	{
	//Key is pressed
	Delay();
	printf ("9\n");
	}

		//Check C4 (PD11) low or high
	if ( !(*pInputDataReg & (1<<11)) )
	{
	//Key is pressed
	Delay();
	printf ("C\n");
	}

	//Make all rows HIGH
	*pOutputDataReg |= (0x0F);

	//Make R4 Low (PD3)
	*pOutputDataReg &= ~(1<<3);
	//Scan the columns
	//check C1 (PD8) low or high
	if ( !(*pInputDataReg & (1<<8)) )   //(*pInputDataReg & (1<<8)) If this evaluation returns 0  the key is pressed C1 PB8 if 1 not pressed due to the & operator
	//So, If we use the ! operator 0 is inverted so 0 means 1 and 1 means 0 we did because the loop needs to be evaluated when the key is pressed that means 0.
	{

	//we need to give delay as per the flow chart
	Delay();
	//Key is pressed
	printf ("*\n");
	}

	//Check C2 (PD9) low or high
	if ( !(*pInputDataReg & (1<<9)) )
	{
		//Key is pressed
	Delay();
	printf ("0\n");
	}

	//Check C3 (PD10) low or high
	if ( !(*pInputDataReg & (1<<10)) )
	{
	//Key is pressed
	Delay();
	printf ("#\n");
	}

		//Check C4 (PD11) low or high
	if ( !(*pInputDataReg & (1<<11)) )
	{
	//Key is pressed
	Delay();
	printf ("D\n");
	}
	}

}
